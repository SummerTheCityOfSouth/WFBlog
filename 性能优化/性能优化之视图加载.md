### 性能优化之视图加载

#### 视图加载的两个方法 

##### loadView 

加载的三种方式 

1.nibs

2.storyBoard

3.自定义UI

> 自定义UI需要注意的三个点 
>
> - 将 view 属性设置到视图层级的根上。 
> - 确保视图正被其他的视图控制器所共享。 
> - 不要调用 [super loadView]。 

##### viewDidLoad

只会被调用一次 ，只是加载来自配置视图的公共任务 

- 配置数据源来填充数据。 

- 为视图绑定数据。 

  这是一个值得商榷的任务。根据不同的使用情况，你可以一次绑定数据，并提供一个刷 新按钮，也可以每次调用 viewWillAppear 时绑定。使用后者的好处是，UI 总是展示最 新的数据;缺点是，如果数据更新不频繁(例如，在新闻应用中)，用户每次看到的都 是不必要的刷新(例如，当 UITableView 重新绑定时)。 

- 绑定视图的事件处理程序、数据源的委托和其他回调。 

- 注册数据的观察者。 

  依据数据绑定到视图时的不同位置，数据的观察者可能也会发生变化。 

- 从通知中心对通知进行监控。 

- 初始化动画。 

  #### 视图层级

  ##### 渲染步骤 

  (1) 构造子视图。
  (2) 计算并提供约束。
  (3) 为子视图递归地执行步骤 1 和步骤 2。
  (4) 递归渲染。

> 耗时时长 
>
> 在一个安装了 iOS 8.1 的 iPhone 6 上，从视图控制器加载(initWithCoder:)到渲染 (viewWillAppear:)之前的平均耗时约为 15 毫秒。而且，这还没有考虑从磁盘(故事板 / nib 文件)一次性加载布局的时间。viewDidAppear:方法会因为过渡动画的原因在约 300 毫秒后被调用。 

##### 视图生命周期

##### viewWillAppear 



##### viewDidAppear 

##### viewWillDisappear 

该方法表示视图将要从屏幕上隐藏起来。这可能是因为其他视图控制器想要接管屏幕， 或该视图控制器将要出栈 

> 可以通过视图在Navigation中的Index来判断是否是销毁视图

##### viewDidDisappear

当上一个 / 下一个视图控制器的过渡动画完成时，此方法会被调用  ，300ms延迟

####  最佳实战 

- 将 viewDidLoad 作为最后的检查点，查看来自数据源的数据是否可用。如果可用，则更 

新 UI 元素。 

- 无需多说，不要重写 loadView
- 使用 viewWillDisappear: 来暂停或停止动画。同样，不要做其他多余的操作。 
- 使用 viewDidDisappear:销毁内存中的复杂数据结构。  

#### 保持界面流畅的基本原则

- 尽量减少在主线程中所做的工作。任何额外代码的执行都意味着更高的丢帧概率。过多 的丢帧会导致不流畅。 

- 避免较大的 nibs 或故事板。故事板很强大，但整个 XML 在真正使用之前必须被加载(I/O) 和解析(XML 处理)。应该最小化故事板中的单元数目。 如果需要的话，创建多个故事板或 nib 文件。这可以确保所有的屏幕并非都在应用启动 时一次性加载，而是根据需要进行加载。这不仅有助于减少应用的启动时间，还能降低 整体内存的消耗值 

- 避免在视图层次结构中多层嵌套。尽量保持扁平化。嵌套是必要的“罪恶”，但仍然是 “罪恶” 

- 尽可能延迟加载视图并进行重用。更多的视图不仅会导致加载时间变长，还会使渲染时 间变长，这些会影响内存和 CPU 的使用 

- 对于复杂的 UI 而言，最好使用自定义绘图。这样只会触发一个视图进行绘制，而不是
  多个子视图，同时也避免了调用代价较高的 layoutSubviews 和 drawRect: 方法。
  此外，要避免使用具有通用目的及功能丰富的组件而带来的消耗，你可以使用那些直接
  实现了绘制方法的视图来代替。

  > Tips：如果将动态计算出的标签宽度作为容器宽度的一小部分，那么你要确保宽度可以由某一百
  > 分比均匀分配。例如，两个标签各占容器宽度的 50%，那么容器宽度必须是偶数。避免
  > width/2 这样的调用。如果宽度很小，其他的都不会受影响，除了渲染，因为渲染需要反
  > 锯齿，这是一个代价很大的操作



#### UITableView 优化流畅 

1. 重用Cell
2. 尽可能避免动态高度的单元格 
3. 如果你真的需要动态高度的单元格，那么定义一个规则来标记单元格是脏的。如果某个 单元格是脏的，计算它的高度并缓存 
4. 当用自定义视图重用单元格时，要避免通过调用 layoutIfNeeded 每次都对其进行布局 
5. 避免透明的单元格子视图 
6. 在快速滚动时考虑使用界面外壳(见图 6-7)。当用户快速滚动列表视图时，虽然使用了 所有的优化，但视图的重用和渲染仍然需要超过 16 毫秒，还有可能出现偶发的丢帧现 象，从而导致不流畅的体验 在这些情况下，使用一个界面外壳是一个较好的选择，外壳可以被预先定义，它的唯一
   目的就是告诉终端用户这些部分即将展示一些数据。当滚动速度降低，并低于阈值时，
   刷新最终的视图并填充数据

```objective-c
监听滑动速度
-(void)scrollViewDidScroll:(UIScrollView *)scrollView { 
  CGPoint velocity = [tableView.panGestureRecognizer velocityInView:self.view];
  self.velocity = velocity;
}
-(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {
  if(fabs(self.velocity.y) > 2000) {
	//返回界面外壳 
  } else {
	//返回真正的单元格 
  }
}
```

7. 避免渐变、图像缩放以及任何屏幕外的绘制。这些效果对 CPU 以及图形处理单元(GPU)
   来说都是消耗