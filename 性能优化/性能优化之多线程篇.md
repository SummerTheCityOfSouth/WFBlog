### 性能优化之多线程篇

#### 线程

##### 1.什么是线程 

##### 2.线程的开销

#####2.1 线程的数据结构

每个线程大约消耗 1KB 的内核内存空间。这块内存用于存储与线程有关的数据结构和属 

性。这块内存是联动内存(wired memory)，无法被分页 

##### 2.2 栈空间

主线程的栈空间大小为 1M，而且无法修改。所有的二级线程默认分配 512KB 的栈空间

#####2.3GCD的线程池上线 `很有可能达到线程的限制 64 个，2,3 即 GCD 的线程池上限`

##########2.4操作和队列 

NSOperation 和 NSOperationQueue 都提供控制线程个数的能力。可用 maxConcurrentOpera-
tionCount 属性控制队列的个数，也可以控制每个队列的线程个数



#### 三种线程操作的比较 

• GCD 

- ♦  抽象程度最高。 
- ♦  两种队列开箱即用:main 和 global。 
- ♦  可以创建更多的队列(使用 dispatch_queue_create)。 
- ♦  可以请求独占访问(使用 dispatch_barrier_sync 和 dispatch_barrier_async)。 
- ♦  基于线程管理。 
- ♦  硬性限制创建 64 个线程。 

• NSOperationQueue 

- ♦  无默认队列。 
- ♦  应用管理自己创建的队列。 
- ♦  队列是优先级队列。 
- ♦  操作可以有不同的优先级(使用 queuePriority 属性)。
- ♦  使用 cancel 消息可以取消操作。注意，cancel 仅仅是个标记。如果操作已经开始 执行，则可能会继续执行下去。 
- ♦  可以等待某个操作执行完毕(使用 waitUntilFinished 消息)。  

• NSThread 

- ♦  低级别构造，最大化控制。 
- ♦  应用创建并管理线程。 
- ♦  应用创建并管理线程池。 
- ♦  应用启动线程。 
- ♦  线程可以拥有优先级，操作系统会根据优先级调度它们的执行。 
- ♦  无直接 API 用于等待线程完成。需要使用互斥量(如 NSLock)和自定义代码。 

#### 锁

#####3.1 NSLock

这是一种低级别的锁。一旦获取了锁，执行则进入临界区，且不会允许超过一个线程并
行执行。释放锁则标记着临界区的结束

`NSLock 必须在锁定的线程中进行解锁。`<单线程 可用>

##### 3.2 NSRecursiveLock

NSRecursiveLock 允许在被解锁前锁定多次。如果解锁的次数与锁定的次数相匹配，则
认为锁被释放，其他线程可以获取锁 `多线程 可用`

用途： 当类中有多个方法使用同一个锁进行同步，且其中`一个方法调用另一个方法时`，
NSRecursiveLock 非常有用

##### 3.3 NSCondition

有些情况需要协调线程之间的执行。例如，一个线程可能需要等待其他线程返回结果。 NSCondition 可以原子性地释放锁，从而使得其他等待的线程可以获取锁，而初始的线 程继续等待。 

​	一个线程会等待释放锁的条件变量。另一个线程会通知条件变量释放该锁，并唤醒等待 中的线程。 

用途 ：使用 NSCondition 解决标准的`生产者—消费者问题 `

##### 3.2

##### 3.5两种初始化器

1) 使用自定义的初始化器 

- 会有很长的方法名 如果再加五个属性，初始化器会迅速膨胀
- 还会带来向下兼容的问题 加入更多属性的新版模型无法向下兼容。但
  是，这也令使用了新版模型的应用能够在编译时知道什么地方发生了改变

2) 使用生成器模式

- 生成器模式需要引入外部类进行管理 setter 方法，也需要提供与模型数据
  完全一致的存储。生成器最终也会使用初始化器

  推荐使用生成器模式，因为它支持向下兼容，而且即使不再加入新的属性，生成器也不会
  破坏应用。新版模型中的新增属性将继续持有其默认值

  优点 ： 

  - 模型总是向下兼容。新版的模型生成器包含了新增属性，但不会破坏 createUser 的代码 

  - 生成器可以被直接创建。模型的消费者可以初始化生成器，并调用 build 方法创建模型 

    对象 

    - 生成器的创建和处理可以留给内部核心完成。模型的消费者可以使用类方法 userWithBlock: 

    而无需初始化或亲自调用 build 方法。 

##### 3.2

##### 3.2

##### 3.2