### 类和结构体

##### 类和结构体的共同之处

1. 定义属性来存储值
2. 定义方法提供功能
3. 定义下标脚本来允许使用下标语法访问值
4. 定义初始化器用于初始化状态
5. 可以被扩展来默认所没有的功能
6. 遵循协议来针对特定类型提供标准功能

简单来说就是属性，方法，下标，初始化方法，添加扩展，最后协议

##### 类独有的功能

1. 继承
2. 类型转换，可以允许运行检查和解释一个实例的类型
3. 反初始化器，允许一个类实例释放任何其所分配的资源
4. 引用计数

##### 类和结构体之间的选择

以下通常使用结构体：

1. （简洁数据）主要封装一些相关的简单数据
2. （传递值拷贝）当赋值或者传递结构体实例时，有理由需要封装的数据值被拷贝而不是引用 
3. （值拷贝）任何储存在结构体中的属性是值类型，也将被拷贝，而不是引用
4. （无继承）结构体不需要从一个已存在类型继承属性或者行为

#### 属性

属性观察者 

属性观察者会观察并对属性值的变化做出回应，每当一个属性的值被设置时，属性观察都会被调用，即使这个值与该属性当前的值相同

#### 类型属性 类似于单例模式

##### 类似于类属性

> 在swift中 枚举和结构体用 static没有class属性
>
> 在类中用class属性 

实例属性是属于特定类型属性的属性，每次创建这个类型的新实例，它就拥有一对属性值，与其他实例不同，

在类中只有一个这个实例的copy，这样的类型叫类型属性

语法 在前面添加一个static关键字

```swift

struct SomeStructure {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 1
    }
}
enum SomeEnumeration {
    static var storedTypeProperty = "Some value."
    static var computedTypeProperty: Int {
        return 6
    }
}
```

##### Mutating 修改属性

值类型，默认情况是不能被自身的实例方法修改，将这个方法异变才可以 

```swift
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        x += deltaX
        y += deltaY
    }
}
var somePoint = Point(x: 1.0, y: 1.0)
somePoint.moveBy(x: 2.0, y: 3.0)
print("The point is now at (\(somePoint.x), \(somePoint.y))")
// prints "The point is now at (3.0, 4.0)"

```



mutating关键字也可以用改变自身

```swift
///和上面是一样的
struct Point {
    var x = 0.0, y = 0.0
    mutating func moveBy(x deltaX: Double, y deltaY: Double) {
        self = Point(x: x + deltaX, y: y + deltaY)
    }
}
```



根据swift特性来编写代码，用mutating来隐藏要做的内容

```swift

enum TriStateSwitch {
    case off, low, high
    mutating func next() {
        switch self {
        case .off:
            self = .low
        case .low:
            self = .high
        case .high:
            self = .off
        }
    }
}

```

##### 下标

类和结构体枚举都可以定义下标，作为访问集合列表或者序列成员的快捷方式

```swift

subscript(index: Int) -> Int {
    get {
        // return an appropriate subscript value here
    }
    set(newValue) {
        // perform a suitable setting action here
    }
}
```



##### 类型下标

在结构体或者枚举中可以用static来表示在类中用class来表示一个类型下标 

```swift
enum Planet: Int {
    case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune
    static subscript(n: Int) -> Planet {
        return Planet(rawValue: n)!
    }
}
let mars = Planet[4]
print(mars)
```

> 在UITableView有多个section的时候，我们通常使用枚举来代表枚举来代表每个section，用下标来取枚举会很舒服



#### Swift中的继承

##### 基类

swift中不会像OC那样会继承一个基类，如果一个类没有继承那就是基类

##### 子类 

子类是基于现有类创建新的类的行为，

子类从现有的类继承了一些特征，你可以重新定义他们，也可以添加新的特征

##### 阻止重写

在属性，下标，或者方法里面写一个final表示阻止重写



### 初始化和反初始化

#### 初始化

初始化就是为类，结构体，或者枚举准备实例的过程，这个过程需要给实例的每一个存储属性设置一个初始化值并且在新的实例可以使用之前执行任何所必须的配置或者初始化

##### 为存储属性设置初始化值

##### 自定义初始化

##### 默认初始化器

给类一个默认初始化器，为可选值的话，默认值就为nil

##### 结构体类型的成员初始化器

如果机构提类型中没有定义任何自定义初始化器，她会自动或得一个成员初始化器，不同于默认，结构体会接收成员初始化器，即使他的储存属性没有默认值

，当你调用成员初始化器时，你可以声乐任何拥有默认值的属性



##### 值类型的初始化器委托

在初始化器可以调用其他初始化器来执行部分实例的初始化

值类型是不支持继承的，初始化简单

> 如果你为值类型定义了自定义初始化器，你就不能访问那个类型的默认初始化器，或者是成员初始化器，这个是限制防止别人以外地使用自动初始化器，从而绕过复杂初始化器里提供的额外必要 配置这样情况发生

##### 类的继承和初始化

指定初始化器 和便捷初始化器

`指定初始化器`是类的主要初始化器。指定的初始化器可以初始化所有那个类引用的属性并且调用合适的父类初始化器来继续这个初始化过程给父类链。

`便捷初始化器`是次要的，为一个类支持初始化器。你可以在相同的类里定义一个便捷初始化器来调用一个指定的初始化器作为便捷初始化器来给指定初始化器设置默认形式参数



> 类类型的舒适化委托主要有如下规则：
>
> 1. 指定初始化器需要从他的直系父类调用指定初始化器
> 2. 便捷初始化器必须从相同的类里调用另一个初始化器
> 3. 便捷初始化器最终必须调用一个指定初始化器
>
> 原理就是 指定初始化器必须总是向上委托，便捷初始化器必须是横向委托
>
> 便捷初始化器可以调用便捷初始化器，但是最终还是要调用指定初始化器

> 两段初始化
>
> swift类初始化是一个两段式过程，
>
> 1. 在每一个存储属性呗引入类为分配了一个初始值，一单每个存储属性的初始状态被确定，第二个阶段就开始了，每个类都有机会在新的实例准备使用之前来定制他的存储属性
>
>    简单来说就是 初始化 + 定制的过程

> 安全检查 ：
>
> 1. （先初始化子类，在父类）指定初始化器必须保证在向上委托给父类初始化器之前，其所在类引入的所有属性都要初始化完成、
> 2. （继承的属性，先初始化父类，在设置新值 ）指定初始化器必须向上委托父类初始化器，然后才能为继承的属性设置新值 
> 3. （先调用初始化器，在赋值）便捷初始化器必须现委托同类中的其他初始化器，然后 再为任意属性赋新值
> 4. 初四花在第一阶段初始化完成之前，不能调用任何实例方法，不能读取任何实例属性的值，也不能引用self作为值

> 自动继承父类初始化器的情况 
>
> 1. 子类没有定义任何指定初始化器
> 2. 如果子类提供了所有父类指定初始化器的实现，要么通过规则1，要么通过在定义中提供自定义实现的— 那么他自动继承所有的父类便捷初始化器



##### 可失败初始化器

##### 必要初始化器



#### 反初始化

init 和deinit 关键字一样，只有在类类型中有效

##### 原理

实例不需要的时候需要被释放掉，以节省资源，类似自动引用计数为零时，释放掉

反初始化器，不接受任何形式参数，并且不需要写圆括号

```swift
deinit{
  
}
```

父类和子类调用顺序，首先调用子类的方法，在调用父类的方法